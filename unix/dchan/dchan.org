As stated before, Dchan is a literate program, then this document is
all you need to understand all of it's concepts, design choices,
and get the source code.

It was developed using [[http://orgmode.org/][orgmode]], but isn't required to use emacs to
build or contribute to the project. The project is composed of org
files and a full featured Makefile. The Makefile have all of the
commands you need to generate the book on various formats, extract the
source code, build the software, execute tests, and so on.

If you use Emacs editor, you don't need this Makefile at all, because
orgmode is fully integrated.

For non-emacs developers, the development process is:

1. Change org files;
2. Run make

*Never touch the generated source code.*

* Dependencies

- Org dependency

If you use Emacs, everything is already installed.

For non-emacs developers, install [[https://github.com/fniessen/orgmk][orgmk]].

- Go

Read the [[https://golang.org/doc/install][Go Getting started]] tutorial.

* Implementation

** dchan-proxy

** Source Makefile

#+BEGIN_SRC makefile :tangle Makefile
all:
	go build -v

test:
	chmod +x tests/acceptance/*.sh
	./tests/acceptance/vfs.sh

clean:
	rm -f tests/acceptance/*.sh
	rm -f *.go
	rm -f Makefile

#+END_SRC

** Testing infrastructure

   One of the greatest motivations for create dchan was testing. It's
   very hard to test messaging nowadays, because of very complex TCP
   protocols and bigger responsability on the client side to guarantee
   reliability of the architecture.

   Dchan shall expose a simple testing interface.

   We'll start writing simple tests to verify the contracts
   established in the [[API][API]] chapter.

   The first tests will verify if dchan exposes a sane filesystem
   interface. We shall be able to create, delete (unlink), write,
   read and stat files.

#+BEGIN_SRC sh :tangle tests/acceptance/vfs.sh :shebang #!/bin/bash
# This functions only test the filesystem interface

DCHANDIR=/tmp/dchan
DCHANPID=""

function mountdchan {
    local cwd="$(pwd)"
    cd ../..

    make build

    ./unix/dchan/dchan -addr ":6666" -d &

    if [ "$?" != "0" ]; then
        echo "Failed to start dchan... Exiting ..."
        unmountdchan
        exit 1
    fi

    DCHANPID=$!

    mkdir -p "${DCHANDIR}"

    sleep 3

    /usr/local/plan9/bin/9pfuse 'tcp!localhost!6666' "${DCHANDIR}"

    if [ "$?" != "0" ]; then
        echo "Failed to mount 9P"
        unmountdchan
        exit 1
    fi

    sleep 1

    cd "${cwd}"

    if [ "$?" != "0" ]; then
        echo "Failed to enter into dchan directory"
        unmountdchan
        exit 1
    fi
}

function unmountdchan {
    cd /

    echo "PWD=$(pwd)"

    /usr/local/plan9/bin/unmount ${DCHANDIR}

    sleep 10

    rm -rf ${DCHANDIR}

    if [ "${DCHANPID}" != "" ]; then
       kill ${DCHANPID}
    fi
}

function changedir {
    local cwd="$(pwd)"

    echo "Current dir=$(pwd)"
    cd ${DCHANDIR}
    echo "Current dir=$(pwd)"
    cd "${cwd}"
    echo "Current dir=$(pwd)"
}

mountdchan
changedir
unmountdchan

#+END_SRC

** Main module

Main is the module responsible to parse the command-line arguments and
initialize the 9P file server.

#+NAME: src|main.go
#+BEGIN_SRC go :tangle main.go :noweb true
package main

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/lionkov/go9p/p"
	"github.com/lionkov/go9p/p/srv"
)

type DchanFile struct {
	srv.File
	id int
}

type Dchan struct {
	srv.File
}

var addr = flag.String("addr", ":6666", "network address")
var debug = flag.Bool("d", false, "print debug messages")

var root *srv.File

func (file *DchanFile) Read(fid *srv.FFid, buf []byte, offset uint64) (int, error) {
	b := []byte("hacked by i4k")
	n := len(b)

	if offset >= uint64(n) {
		return 0, nil
	}

	b = b[int(offset):n]
	n -= int(offset)
	if len(buf) < n {
		n = len(buf)
	}

	copy(buf[offset:int(offset)+n], b[offset:])
	return n, nil
}

func (file *DchanFile) Write(fid *srv.FFid, data []byte, offset uint64) (int, error) {
	return 0, errors.New("permission denied")
}

func (file *DchanFile) Wstat(fid *srv.FFid, dir *p.Dir) error {
	return nil
}

func (file *DchanFile) Remove(fid *srv.FFid) error {
	return nil
}

func main() {
	var err error
	var ctl *DchanFile
	var s *srv.Fsrv

	flag.Parse()
	user := p.OsUsers.Uid2User(os.Geteuid())
	root = new(srv.File)
	err = root.Add(nil, "/", user, nil, p.DMDIR|0777, nil)
	if err != nil {
		goto error
	}

	ctl = new(DchanFile)
	err = ctl.Add(root, "ctl", p.OsUsers.Uid2User(os.Geteuid()), nil, 0444, ctl)
	if err != nil {
		goto error
	}

	s = srv.NewFileSrv(root)
	s.Dotu = true

	if *debug {
		s.Debuglevel = 1
	}

	s.Start(s)
	err = s.StartNetListener("tcp", *addr)
	if err != nil {
		goto error
	}
	return

error:
	log.Println(fmt.Sprintf("Error: %s", err))
}
#+END_SRC

#+RESULTS: src|main.go


* Test cases

** Network partitions

Network partition is the most frequent problem that can affect
Dchan. There's some cases that needs to be covered in order to achieve
reliability in the exchange of messages.



| Description | steps of events |   |   |   |
|-------------+-----------------+---+---+---|
|             |                 |   |   |   |
