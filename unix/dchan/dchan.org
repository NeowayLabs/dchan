As stated before, Dchan is a literate program, then this document is
all you need to understand all of it's concepts, design choices,
and get the source code.

It was developed using [[http://orgmode.org/][orgmode]], but isn't required to use emacs to
build or contribute to the project. The project is composed of org
files and a full featured Makefile. The Makefile have all of the
commands you need to generate the book on various formats, extract the
source code, build the software, execute tests, and so on.

If you use Emacs editor, you don't need this Makefile at all, because
orgmode is fully integrated.

For non-emacs developers, the development process is:

1. Change org files;
2. Run make

*Never touch the generated source code.*

* Dependencies

- Org dependency

If you use Emacs, everything is already installed.

For non-emacs developers, install [[https://github.com/fniessen/orgmk][orgmk]].

- Go

Read the [[https://golang.org/doc/install][Go Getting started]] tutorial.

* Implementation

** dchan-proxy

** Source Makefile

#+BEGIN_SRC makefile :tangle Makefile
all:
	go build -v

test: all
	chmod +x tests/acceptance/*.sh
	./tests/acceptance/vfs.sh

clean:
	rm -f tests/acceptance/*.sh
	rm -f *.go
	rm -f Makefile

#+END_SRC

** Testing infrastructure

   One of the greatest motivations for create dchan was testing. It's
   very hard to test messaging nowadays, because of very complex TCP
   protocols and bigger responsability on the client side to guarantee
   reliability of the architecture.

   Dchan shall expose a simple testing interface.

   We'll start writing simple tests to verify the contracts
   established in the [[API][API]] chapter.

   The first tests will verify if dchan exposes a sane file-system
   interface. We shall be able to create, delete (unlink), write,
   read and stat files.

*** Setup and teardown

    Every test must mount a dchan directory on startup and unmount
    when finished.

    The easiest way to handle file-system mounts is using shell
    scripts. The setup function must:

    1. Create the target dchan directory (eg.: /tmp/dchan)
    2. Run dchan daemon
    3. Mount dchan on target directory using a non-privileged user;
       1. Use FUSE until Linux user namespace isnt stable

    If something fail in the steps above, the operating system should
    be rollback (kill dchan daemon, unmount, delete target dir).

    Below is the /setup/ function:

#+NAME: src-tests-fn-setup
#+BEGIN_SRC sh
# Setup receives the target directory as parameter
function setup {
    local cwd="$(pwd)"
    local dchandir="$1"
    cd ../..

    # Dchan should be built before running tests
    ./unix/dchan/dchan -addr ":6666" -d &

    if [ "$?" != "0" ]; then
        echo "Failed to start dchan... Exiting ..."
        teardown "${dchandir}" ""
        exit 1
    fi

    # Store dchan pid for later kill
    local dchanpid=$!

    # wait for dchan initialization
    sleep 3

    mkdir -p "${dchandir}"

    9pfuse 'tcp!localhost!6666' "${dchandir}"

    if [ "$?" != "0" ]; then
        echo "Failed to mount 9P"
        teardown "${dchandir}" "${dchanpid}"
        exit 1
    fi

    # wait for 9P client-server handshake
    sleep 1

    cd "${cwd}"

    if [ "$?" != "0" ]; then
        echo "Failed to enter into dchan directory"
        teardown "${dchandir}" "${dchanpid}"
        exit 1
    fi

    echo -n "${dchanpid}"
}
#+END_SRC

    Below is the teardown function:

#+NAME: src-tests-fn-teardown
#+BEGIN_SRC sh
# teardown(dchandir, dchanpid)
# dchandir -> target directory
# dchanpid -> pid of dchan daemon
function teardown {
    local dchandir="$1"
    local dchanpid="$2"

    echo "PWD=$(pwd)"

    unmount "${dchandir}"

    sleep 3

    rm -rf "${dchandir}"

    if [ "${DCHANPID}" != "" ]; then
       kill "${dchanpid}"
    fi
}
#+END_SRC

    The changedir tests is simply:

#+NAME: src-tests-acceptance
#+BEGIN_SRC sh :noweb yes :tangle tests/acceptance/vfs.sh :shebang #!/bin/bash
# This functions only test the filesystem interface

DCHANDIR=/tmp/dchan

<<src-tests-fn-setup>>

<<src-tests-fn-teardown>>

function changedir {
    local cwd="$(pwd)"

    echo "Current dir=$(pwd)"
    cd ${DCHANDIR}
    echo "Current dir=$(pwd)"
    cd "${cwd}"
    echo "Current dir=$(pwd)"
}

DCHANPID=$(setup "${DCHANDIR}")
changedir
teardown "${DCHANDIR}" "${DCHANPID}"

#+END_SRC

** Main module

Main is the module responsible to parse the command-line arguments and
initialize the 9P file server.

#+NAME: src|main.go
#+BEGIN_SRC go :tangle main.go :noweb true
package main

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/lionkov/go9p/p"
	"github.com/lionkov/go9p/p/srv"
)

type DchanFile struct {
	srv.File
	id int
}

type Dchan struct {
	srv.File
}

var addr = flag.String("addr", ":6666", "network address")
var debug = flag.Bool("d", false, "print debug messages")

var root *srv.File

func (file *DchanFile) Read(fid *srv.FFid, buf []byte, offset uint64) (int, error) {
	b := []byte("hacked by i4k")
	n := len(b)

	if offset >= uint64(n) {
		return 0, nil
	}

	b = b[int(offset):n]
	n -= int(offset)
	if len(buf) < n {
		n = len(buf)
	}

	copy(buf[offset:int(offset)+n], b[offset:])
	return n, nil
}

func (file *DchanFile) Write(fid *srv.FFid, data []byte, offset uint64) (int, error) {
	return 0, errors.New("permission denied")
}

func (file *DchanFile) Wstat(fid *srv.FFid, dir *p.Dir) error {
	return nil
}

func (file *DchanFile) Remove(fid *srv.FFid) error {
	return nil
}

func main() {
	var err error
	var ctl *DchanFile
	var s *srv.Fsrv

	flag.Parse()
	user := p.OsUsers.Uid2User(os.Geteuid())
	root = new(srv.File)
	err = root.Add(nil, "/", user, nil, p.DMDIR|0777, nil)
	if err != nil {
		goto error
	}

	ctl = new(DchanFile)
	err = ctl.Add(root, "ctl", p.OsUsers.Uid2User(os.Geteuid()), nil, 0444, ctl)
	if err != nil {
		goto error
	}

	s = srv.NewFileSrv(root)
	s.Dotu = true

	if *debug {
		s.Debuglevel = 1
	}

	s.Start(s)
	err = s.StartNetListener("tcp", *addr)
	if err != nil {
		goto error
	}
	return

error:
	log.Println(fmt.Sprintf("Error: %s", err))
}
#+END_SRC

#+RESULTS: src|main.go


* Test cases

** Network partitions

Network partition is the most frequent problem that can affect
Dchan. There's some cases that needs to be covered in order to achieve
reliability in the exchange of messages.



| Description | steps of events |   |   |   |
|-------------+-----------------+---+---+---|
|             |                 |   |   |   |
